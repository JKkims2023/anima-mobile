/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * üé¥ PersonaCardView Component
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Regular persona full-screen view with flip animation
 * 
 * Features:
 * - Full screen layout (like Manager SAGE)
 * - Front: Persona info (video/image, name, stats)
 * - Back: Memories (180¬∞ flip animation)
 * - Tap to flip
 * - Haptic feedback
 * 
 * @author JK & Hero AI
 * @date 2024-11-21
 */

import React, { useState, useRef, useEffect, useMemo, memo } from 'react';
import {
  View,
  TouchableOpacity,
  Image,
  StyleSheet,
  Dimensions,
  Animated,
  Platform,
  ActivityIndicator,
} from 'react-native';
import Video from 'react-native-video';
// import FastImage from 'react-native-fast-image'; // ‚≠ê TEMP: Testing with native Image
import { BlurView } from '@react-native-community/blur';
import { useTranslation } from 'react-i18next';
import { useTheme } from '../../contexts/ThemeContext';
import { scale, verticalScale } from '../../utils/responsive-utils';
import CustomText from '../CustomText';
import HapticService from '../../utils/HapticService';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
// PersonaChatView is now rendered in PersonaSwipeViewer (outside FlatList)

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');

/**
 * PersonaCardView Component
 * @param {Object} props
 * @param {Object} props.persona - Persona data
 * @param {boolean} props.isActive - Whether this persona is currently active/selected
 * @param {boolean} props.isScreenFocused - Whether the screen is focused (for video playback)
 * @param {Animated.Value} props.modeOpacity - Opacity animation value from parent (for mode transition)
 * @param {number} props.availableHeight - Available height (excluding header, tabbar, etc.)
 * @param {Function} props.onCheckStatus - Callback when user clicks "Check Status" button
 */
const PersonaCardView = ({ 
  persona, 
  isActive = false, 
  isScreenFocused = true,
  modeOpacity,
  typingMessage = null,
  isLoading = false,
  chatInputBottom = 0,
  availableHeight = SCREEN_HEIGHT,
  onCheckStatus, // ‚≠ê NEW: Callback for status check
}) => {
  const { currentTheme } = useTheme();
  const { t } = useTranslation();
  const [isFlipped, setIsFlipped] = useState(false);
  const [videoLoaded, setVideoLoaded] = useState(false);
  const [modeOpacityValue, setModeOpacityValue] = useState(1);
  const [remainingSeconds, setRemainingSeconds] = useState(null); // ‚≠ê NEW: Countdown timer
  const [isCheckingStatus, setIsCheckingStatus] = useState(false); // ‚≠ê NEW: Loading state for check button
  const flipAnim = useRef(new Animated.Value(0)).current;
  const videoOpacity = useRef(new Animated.Value(0)).current;
  const containerOpacity = useRef(new Animated.Value(0)).current;
  const insets = useSafeAreaInsets();
  
  const HEADER_HEIGHT = verticalScale(80); // Ìó§Îçî ÎÜíÏù¥ (ÌÉÄÏù¥ÌãÄ + ÏÑúÎ∏åÌÉÄÏù¥ÌãÄ + Ìå®Îî©)
  const TAB_BAR_HEIGHT = verticalScale(60); // ÌÉ≠Î∞î ÎÜíÏù¥
  
  const availableHeight_local = SCREEN_HEIGHT  - HEADER_HEIGHT - insets.bottom - TAB_BAR_HEIGHT;
  
  // ‚úÖ Listen to modeOpacity changes to pause video when mode is switching
  useEffect(() => {
    if (!modeOpacity) {
      setModeOpacityValue(1); // Default to visible if no modeOpacity
      return;
    }
    
    // ‚≠ê Handle both Animated.Value and number
    if (typeof modeOpacity === 'number') {
      setModeOpacityValue(modeOpacity);
      return;
    }
    
    const listenerId = modeOpacity.addListener(({ value }) => {
      setModeOpacityValue(value);
    });
    
    return () => {
      modeOpacity.removeListener(listenerId);
    };
  }, [modeOpacity]);

  // ‚≠ê NEW: Timer logic for persona creation
  useEffect(() => {
    // Only run if persona is incomplete
    if (persona?.done_yn !== 'N') {
      setRemainingSeconds(null);
      return;
    }

    // Calculate remaining time based on server data
    const calculateRemainingTime = () => {
      if (!persona.created_date || !persona.estimate_time) {
        console.warn('[PersonaCardView] Missing created_date or estimate_time:', persona);
        return 0;
      }

      const now = Date.now();
      const createdDate = new Date(persona.created_date).getTime();
      const elapsedSeconds = Math.floor((now - createdDate) / 1000);
      const remaining = Math.max(0, persona.estimate_time - elapsedSeconds);

      return remaining;
    };

    // Initial calculation
    const initialRemaining = calculateRemainingTime();
    setRemainingSeconds(initialRemaining);

    // ‚≠ê FIX: Stop timer if already at 0
    if (initialRemaining === 0) {
      return;
    }

    // Update every second
    const interval = setInterval(() => {
      const remaining = calculateRemainingTime();
      setRemainingSeconds(remaining);
      
      // ‚≠ê FIX: Stop interval when reaching 0
      if (remaining === 0) {
        clearInterval(interval);
      }
    }, 1000);

    return () => {
      clearInterval(interval);
    };
  }, [persona?.done_yn, persona?.created_date, persona?.estimate_time, persona?.persona_name]);

  // ‚úÖ Determine media source (Video or Image) - Memoized
  const { hasVideo, videoUrl, imageUrl } = useMemo(() => {
    const hasVideo = 
      persona?.selected_dress_video_url !== null && 
      persona?.selected_dress_video_convert_done === 'Y';
    
    const videoUrl = hasVideo ? persona.selected_dress_video_url : null;
    const imageUrl = persona?.selected_dress_image_url || persona?.original_url;
    
    // ‚≠ê DEBUG: ALWAYS log image URL for debugging
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log('üñºÔ∏è [PersonaCardView] Image URL (ALL CASES):');
    console.log('  - Persona:', persona.persona_name);
    console.log('  - done_yn:', persona?.done_yn);
    console.log('  - selected_dress_image_url:', persona?.selected_dress_image_url);
    console.log('  - original_url:', persona?.original_url);
    console.log('  - Final imageUrl:', imageUrl);
    console.log('  - imageUrl type:', typeof imageUrl);
    console.log('  - imageUrl is truthy?', !!imageUrl);
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    
    return { hasVideo, videoUrl, imageUrl };
  }, [
    persona?.selected_dress_video_url,
    persona?.selected_dress_video_convert_done,
    persona?.selected_dress_image_url,
    persona?.original_url,
    persona?.done_yn,
    persona?.persona_name,
  ]);

  // ‚úÖ Control container opacity based on isActive and isScreenFocused
  useEffect(() => {
    const shouldShow = isActive && isScreenFocused && modeOpacityValue > 0;
    const opacityValue = shouldShow ? 1 : 0;
    containerOpacity.setValue(opacityValue);
    
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log('üé® [PersonaCardView] Container Opacity UPDATE');
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log('Persona:', persona.persona_name);
    console.log('isActive:', isActive);
    console.log('isScreenFocused:', isScreenFocused);
    console.log('modeOpacityValue:', modeOpacityValue);
    console.log('shouldShow:', shouldShow);
    console.log('‚Üí containerOpacity set to:', opacityValue);
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
  }, [isActive, isScreenFocused, modeOpacityValue, persona.persona_name]);

  // ‚úÖ Handle video load
  const handleVideoLoad = () => {
    if (__DEV__) {
      console.log('[PersonaCardView] üé¨ Video Loaded:', persona.persona_name);
    }
    setVideoLoaded(true);
    // Fade in video (instant for now to debug)
    videoOpacity.setValue(1);
    
    if (__DEV__) {
      console.log('[PersonaCardView] üé• Video Opacity Set to 1:', persona.persona_name);
    }
  };

  // ‚úÖ Log screen focus changes (for debugging video playback)
  useEffect(() => {
    const isPaused = !isScreenFocused || !isActive;
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log('üé• [PersonaCardView] Screen focus changed:', persona.persona_name);
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log('Props:');
    console.log('  - isScreenFocused:', isScreenFocused);
    console.log('  - isActive:', isActive);
    console.log('  - hasVideo:', hasVideo);
    console.log('Computed:');
    console.log('  - Video paused:', isPaused, isPaused ? '‚è∏Ô∏è PAUSED' : '‚ñ∂Ô∏è PLAYING');
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
  }, [isScreenFocused, isActive, persona.persona_name, hasVideo]);

  // ‚úÖ Only log when actually rendering (isActive = true)
  if (__DEV__ && isActive) {
    console.log('[PersonaCardView] üé¨ Active Render:', persona.persona_name, {
      hasVideo,
      videoUrl: videoUrl ? '‚úÖ Yes' : '‚ùå No',
      convert_done: persona?.selected_dress_video_convert_done,
      isScreenFocused,
      paused: !isScreenFocused || !isActive,
      modeOpacityValue,
      videoOpacity: videoOpacity._value,
      videoLoaded,
      willRenderVideo: isActive && hasVideo && modeOpacityValue > 0,
    });
  }

  // ‚úÖ Handle card flip
  const handleFlip = () => {
    // üéØ Haptic feedback
    HapticService.light();

    const toValue = isFlipped ? 0 : 1;

    Animated.spring(flipAnim, {
      toValue,
      friction: 8,
      tension: 10,
      useNativeDriver: true,
    }).start();

    setIsFlipped(!isFlipped);
  };

  // ‚úÖ Interpolate rotation
  const frontRotation = flipAnim.interpolate({
    inputRange: [0, 1],
    outputRange: ['0deg', '180deg'],
  });

  const backRotation = flipAnim.interpolate({
    inputRange: [0, 1],
    outputRange: ['180deg', '360deg'],
  });

  const frontOpacity = flipAnim.interpolate({
    inputRange: [0, 0.5, 1],
    outputRange: [1, 0, 0],
  });

  const backOpacity = flipAnim.interpolate({
    inputRange: [0, 0.5, 1],
    outputRange: [0, 0, 1],
  });

  return (
    <View style={[styles.container, { height: availableHeight_local }]} pointerEvents="box-none">
      {/* 1. Background Image (Native Image) - Testing if FastImage is the issue */}
      <Image
        source={{ uri: imageUrl }}
        style={styles.backgroundMedia}
        resizeMode="cover"
        onLoad={() => {
          console.log('‚úÖ [PersonaCardView] Image LOADED:', persona.persona_name, imageUrl);
        }}
        onError={(error) => {
          console.error('‚ùå [PersonaCardView] Image ERROR:', persona.persona_name, imageUrl, error);
        }}
      />

      {/* 2. Video Layer (Always render if hasVideo, control with opacity and paused) */}
      {hasVideo && (
        <Animated.View 
          style={[
            styles.videoContainer, 
            { 
              height: availableHeight_local,
              opacity: Animated.multiply(containerOpacity, videoOpacity)
            }
          ]} 
          pointerEvents="none"
        >
          <Video
            key={`video-${persona.persona_key}`}
            source={{ uri: videoUrl }}
            poster={imageUrl}
            posterResizeMode="cover"
            style={styles.backgroundMedia}
            resizeMode="cover"
            repeat
            muted
            paused={!isScreenFocused || !isActive}
            playInBackground={true}
            playWhenInactive={true}
            ignoreSilentSwitch="ignore"
            onLoad={handleVideoLoad}
            onError={(error) => {
              if (__DEV__) {
                console.error('[PersonaCardView] Video Error:', persona.persona_name, error);
              }
            }}
          />
        </Animated.View>
      )}

      {/* ‚≠ê NEW: Incomplete Persona UI (Blur + Timer + Check Button) */}
      {persona?.done_yn === 'N' && remainingSeconds !== null && (
        <View style={styles.incompleteOverlay}>
          <BlurView
            style={styles.blurContainer}
            blurType="light"
            blurAmount={10}
            reducedTransparencyFallbackColor="rgba(255, 255, 255, 0.3)"
          />
          <View style={styles.timerContainer}>
            <CustomText type="title" bold style={styles.generatingText}>
              ‚è≥ {t('persona.creation.generating')}
            </CustomText>
            
            {remainingSeconds > 0 ? (
              <CustomText type="big" bold style={styles.timerText}>
                {t('persona.creation.remaining_time', { time: remainingSeconds })}
              </CustomText>
            ) : (
              <TouchableOpacity
                style={[
                  styles.checkButton,
                  isCheckingStatus && styles.checkButtonDisabled
                ]}
                onPress={() => {
                  if (!isCheckingStatus && onCheckStatus) {
                    HapticService.success();
                    setIsCheckingStatus(true);
                    onCheckStatus(persona, () => {
                      setIsCheckingStatus(false);
                    });
                  }
                }}
                disabled={isCheckingStatus}
                activeOpacity={0.7}
              >
                {isCheckingStatus ? (
                  <ActivityIndicator color="#FFFFFF" size="small" />
                ) : (
                  <CustomText type="middle" bold style={styles.checkButtonText}>
                    {t('persona.creation.check_status')}
                  </CustomText>
                )}
              </TouchableOpacity>
            )}
          </View>
        </View>
      )}

      {/* 3. Chat Overlay - Removed (now rendered in PersonaSwipeViewer) */}
    </View>
  );
};

const styles = StyleSheet.create({
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // Main Container
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  container: {
    flex: 1,
    width: SCREEN_WIDTH,
    // ‚úÖ Removed height: SCREEN_HEIGHT to match SAGE behavior
    // This allows chatOverlay bottom positioning to work correctly
    backgroundColor: '#000000',
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // Background Media (FastImage) - Always visible
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  backgroundMedia: {
    /*
    position: 'absolute',
    top: 0,
    left: 0,
    width: SCREEN_WIDTH,
    height: SCREEN_HEIGHT,
    */
    ...StyleSheet.absoluteFillObject,
    zIndex: 0,
    ...(Platform.OS === 'android' && {
      elevation: 0,
    }),
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // Video Container (Fades in over image)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  videoContainer: {
 //   position: 'absolute',
 //   top: 0,
 //   left: 0,
    width: SCREEN_WIDTH,
//    height: SCREEN_HEIGHT,
    zIndex: 1,
    ...(Platform.OS === 'android' && {
      elevation: 1,
    }),
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // Overlay Container (Flip-able)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  overlayContainer: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    height: SCREEN_HEIGHT * 0.35, // 35% of screen height
    zIndex: 10,
    ...(Platform.OS === 'android' && {
      elevation: 10,
    }),
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // Info Card (Front and Back)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  infoCard: {
    position: 'absolute',
    width: '100%',
    height: '100%',
    backfaceVisibility: 'hidden',
    overflow: 'hidden',
  },

  backCard: {
    // Additional styles for back card
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // Gradient Overlay (for text readability)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  gradientOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0, 0, 0, 0.6)',
    zIndex: -1,
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // Front Content
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  infoContent: {
    flex: 1,
    padding: scale(20),
    justifyContent: 'flex-end',
  },

  nameText: {
    marginBottom: verticalScale(8),
    fontSize: scale(28),
    textShadowColor: 'rgba(0, 0, 0, 0.75)',
    textShadowOffset: { width: 0, height: 1 },
    textShadowRadius: 3,
  },

  descriptionText: {
    marginBottom: verticalScale(15),
    fontSize: scale(14),
    textShadowColor: 'rgba(0, 0, 0, 0.75)',
    textShadowOffset: { width: 0, height: 1 },
    textShadowRadius: 3,
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // Stats
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  statsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginTop: verticalScale(15),
    paddingTop: verticalScale(15),
    borderTopWidth: 1,
    borderTopColor: 'rgba(255, 255, 255, 0.2)',
  },

  statItem: {
    alignItems: 'center',
  },

  statLabel: {
    fontSize: scale(11),
    color: '#E0E0E0',
    marginBottom: verticalScale(5),
    textShadowColor: 'rgba(0, 0, 0, 0.75)',
    textShadowOffset: { width: 0, height: 1 },
    textShadowRadius: 2,
  },

  statValue: {
    fontSize: scale(22),
    fontWeight: 'bold',
    color: '#4FC3F7',
    textShadowColor: 'rgba(0, 0, 0, 0.75)',
    textShadowOffset: { width: 0, height: 1 },
    textShadowRadius: 3,
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // Back Content
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  backContent: {
    flex: 1,
    padding: scale(20),
    justifyContent: 'center',
    alignItems: 'center',
  },

  backTitle: {
    marginBottom: verticalScale(10),
    fontSize: scale(24),
    textShadowColor: 'rgba(0, 0, 0, 0.75)',
    textShadowOffset: { width: 0, height: 1 },
    textShadowRadius: 3,
  },

  backSubtitle: {
    marginBottom: verticalScale(30),
    fontSize: scale(14),
    textAlign: 'center',
    textShadowColor: 'rgba(0, 0, 0, 0.75)',
    textShadowOffset: { width: 0, height: 1 },
    textShadowRadius: 3,
  },

  comingSoon: {
    fontSize: scale(16),
    fontStyle: 'italic',
    textAlign: 'center',
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // Flip Hint
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  flipHint: {
    position: 'absolute',
    bottom: scale(20),
    right: scale(20),
    fontSize: scale(11),
    color: '#B0B0B0',
    textShadowColor: 'rgba(0, 0, 0, 0.75)',
    textShadowOffset: { width: 0, height: 1 },
    textShadowRadius: 2,
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // Incomplete Persona UI
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  incompleteOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 999,
  },
  blurContainer: {
    ...StyleSheet.absoluteFillObject,
  },
  timerContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: scale(30),
  },
  generatingText: {
    fontSize: scale(24),
    color: '#FFFFFF',
    marginBottom: verticalScale(20),
    textShadowColor: 'rgba(0, 0, 0, 0.9)',
    textShadowOffset: { width: 0, height: 2 },
    textShadowRadius: 4,
  },
  timerText: {
    fontSize: scale(40),
    color: '#4FC3F7',
    fontWeight: '900',
    textShadowColor: 'rgba(0, 0, 0, 0.9)',
    textShadowOffset: { width: 0, height: 2 },
    textShadowRadius: 6,
  },
  checkButton: {
    backgroundColor: '#4FC3F7',
    paddingHorizontal: scale(40),
    paddingVertical: verticalScale(15),
    borderRadius: scale(30),
    shadowColor: '#4FC3F7',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.5,
    shadowRadius: 8,
    elevation: 8,
    minWidth: scale(200),
    alignItems: 'center',
  },
  checkButtonDisabled: {
    backgroundColor: '#666666',
    shadowColor: '#666666',
  },
  checkButtonText: {
    fontSize: scale(18),
    color: '#FFFFFF',
    fontWeight: 'bold',
  },
});

// ‚úÖ Memoize PersonaCardView to prevent unnecessary re-renders
// Only re-render when critical props change
export default memo(PersonaCardView, (prevProps, nextProps) => {
  // Return true if props are equal (prevent re-render)
  // Return false if props are different (allow re-render)
  return (
    prevProps.persona.persona_key === nextProps.persona.persona_key &&
    prevProps.persona.done_yn === nextProps.persona.done_yn && // ‚≠ê CRITICAL: Re-render when creation completes
    prevProps.persona.time_done_yn === nextProps.persona.time_done_yn && // ‚≠ê CRITICAL: Re-render when timer completes
    prevProps.persona.persona_url === nextProps.persona.persona_url && // ‚≠ê CRITICAL: Re-render when main image URL updates
    prevProps.persona.original_url === nextProps.persona.original_url && // ‚≠ê CRITICAL: Re-render when original image updates
    prevProps.persona.selected_dress_image_url === nextProps.persona.selected_dress_image_url && // ‚≠ê CRITICAL: Re-render when generated image updates
    prevProps.isActive === nextProps.isActive &&
    prevProps.isScreenFocused === nextProps.isScreenFocused // ‚≠ê CRITICAL: Check isScreenFocused for video control
  );
});

